/**
 * Journey Analytics API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 6.35.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import AUTHChangePasswordDefaultResponse from '../com.alterian.ja.model/AUTHChangePasswordDefaultResponse';
import CreateChannelRequest from '../com.alterian.ja.model/CreateChannelRequest';
import CreateClientDefaultResponse from '../com.alterian.ja.model/CreateClientDefaultResponse';
import CreateEventStreamGroupRequest from '../com.alterian.ja.model/CreateEventStreamGroupRequest';
import CreateEventStreamRequest from '../com.alterian.ja.model/CreateEventStreamRequest';
import CreateIdealisedJourneyRequest from '../com.alterian.ja.model/CreateIdealisedJourneyRequest';
import CreateSankeyFavouriteRequest from '../com.alterian.ja.model/CreateSankeyFavouriteRequest';
import CreateVisualisationFavouriteRequest from '../com.alterian.ja.model/CreateVisualisationFavouriteRequest';
import DeleteChannelRequest from '../com.alterian.ja.model/DeleteChannelRequest';
import DeleteEventStreamCustomerColumnsFromGroupRequest from '../com.alterian.ja.model/DeleteEventStreamCustomerColumnsFromGroupRequest';
import DeleteEventStreamCustomerColumnsRequest from '../com.alterian.ja.model/DeleteEventStreamCustomerColumnsRequest';
import DeleteEventStreamGroupRequest from '../com.alterian.ja.model/DeleteEventStreamGroupRequest';
import DeleteEventStreamRequest from '../com.alterian.ja.model/DeleteEventStreamRequest';
import DeleteIdealisedJourneyRequest from '../com.alterian.ja.model/DeleteIdealisedJourneyRequest';
import DeleteSankeyFavouritesRequest from '../com.alterian.ja.model/DeleteSankeyFavouritesRequest';
import DeleteVisualisationFavouritesRequest from '../com.alterian.ja.model/DeleteVisualisationFavouritesRequest';
import ExportEventStreamInteractionRequest from '../com.alterian.ja.model/ExportEventStreamInteractionRequest';
import GetChannelsDefaultResponse from '../com.alterian.ja.model/GetChannelsDefaultResponse';
import GetClientSetsRequest from '../com.alterian.ja.model/GetClientSetsRequest';
import GetDataSourceUsersDefaultResponse from '../com.alterian.ja.model/GetDataSourceUsersDefaultResponse';
import GetEventRecordsDefaultResponse from '../com.alterian.ja.model/GetEventRecordsDefaultResponse';
import GetEventRecordsRequest from '../com.alterian.ja.model/GetEventRecordsRequest';
import GetEventStreamAggregatesRequest from '../com.alterian.ja.model/GetEventStreamAggregatesRequest';
import GetEventStreamChannelsRequest from '../com.alterian.ja.model/GetEventStreamChannelsRequest';
import GetEventStreamDecodeMappingsDefaultResponse from '../com.alterian.ja.model/GetEventStreamDecodeMappingsDefaultResponse';
import GetEventStreamDecodeMappingsRequest from '../com.alterian.ja.model/GetEventStreamDecodeMappingsRequest';
import GetEventStreamDecodeTargetDiscretesDefaultResponse from '../com.alterian.ja.model/GetEventStreamDecodeTargetDiscretesDefaultResponse';
import GetEventStreamDecodeTargetDiscretesRequest from '../com.alterian.ja.model/GetEventStreamDecodeTargetDiscretesRequest';
import GetEventStreamDefaultResponse from '../com.alterian.ja.model/GetEventStreamDefaultResponse';
import GetEventStreamDiscreteValuesDefaultResponse from '../com.alterian.ja.model/GetEventStreamDiscreteValuesDefaultResponse';
import GetEventStreamDiscreteValuesRequest from '../com.alterian.ja.model/GetEventStreamDiscreteValuesRequest';
import GetEventStreamModelsDefaultResponse from '../com.alterian.ja.model/GetEventStreamModelsDefaultResponse';
import GetEventStreamModelsRequest from '../com.alterian.ja.model/GetEventStreamModelsRequest';
import GetEventStreamRequest from '../com.alterian.ja.model/GetEventStreamRequest';
import GetEventStreamsDefaultResponse from '../com.alterian.ja.model/GetEventStreamsDefaultResponse';
import GetFieldTransformationDiscreteValuesRequest from '../com.alterian.ja.model/GetFieldTransformationDiscreteValuesRequest';
import GetFieldTransformationMappingsDefaultResponse from '../com.alterian.ja.model/GetFieldTransformationMappingsDefaultResponse';
import GetFieldTransformationMappingsRequest from '../com.alterian.ja.model/GetFieldTransformationMappingsRequest';
import GetIdealisedJourneysDefaultResponse from '../com.alterian.ja.model/GetIdealisedJourneysDefaultResponse';
import GetSankeyFavouritesDefaultResponse from '../com.alterian.ja.model/GetSankeyFavouritesDefaultResponse';
import GetSankeyFavouritesRequest from '../com.alterian.ja.model/GetSankeyFavouritesRequest';
import GetVisualisationFavouritesDefaultResponse from '../com.alterian.ja.model/GetVisualisationFavouritesDefaultResponse';
import QueryEventStreamCountDefaultResponse from '../com.alterian.ja.model/QueryEventStreamCountDefaultResponse';
import QueryEventStreamCountRequest from '../com.alterian.ja.model/QueryEventStreamCountRequest';
import QueryEventStreamDefaultResponse from '../com.alterian.ja.model/QueryEventStreamDefaultResponse';
import QueryEventStreamRequest from '../com.alterian.ja.model/QueryEventStreamRequest';
import QueryEventStreamTransitionRequest from '../com.alterian.ja.model/QueryEventStreamTransitionRequest';
import RunSequencePredictorDefaultResponse from '../com.alterian.ja.model/RunSequencePredictorDefaultResponse';
import RunSequencePredictorRequest from '../com.alterian.ja.model/RunSequencePredictorRequest';
import UpdateChannelRequest from '../com.alterian.ja.model/UpdateChannelRequest';
import UpdateEventStreamFieldTransformListsRequest from '../com.alterian.ja.model/UpdateEventStreamFieldTransformListsRequest';
import UpdateIdealisedJourneyRequest from '../com.alterian.ja.model/UpdateIdealisedJourneyRequest';
import UpdateSankeyFavouriteRequest from '../com.alterian.ja.model/UpdateSankeyFavouriteRequest';
import UpdateVisualisationFavouriteRequest from '../com.alterian.ja.model/UpdateVisualisationFavouriteRequest';
import UpsertEventStreamCustomerColumnsRequest from '../com.alterian.ja.model/UpsertEventStreamCustomerColumnsRequest';
import UpsertEventStreamCustomerColumnsToGroupRequest from '../com.alterian.ja.model/UpsertEventStreamCustomerColumnsToGroupRequest';

/**
* EventStreams service.
* @module api/EventStreamsApi
* @version 6.35.0
*/
export default class EventStreamsApi {

    /**
    * Constructs a new EventStreamsApi. 
    * @alias module:api/EventStreamsApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }



    /**
     * Create a channel colour mapping
     * Create a channel colour mapping
     * @param {module:com.alterian.ja.model/CreateChannelRequest} createChannelRequest Create a channel colour mapping
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse} and HTTP response
     */
    createChannelWithHttpInfo(createChannelRequest) {
      let postBody = createChannelRequest;
      // verify the required parameter 'createChannelRequest' is set
      if (createChannelRequest === undefined || createChannelRequest === null) {
        throw new Error("Missing the required parameter 'createChannelRequest' when calling createChannel");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateClientDefaultResponse;
      return this.apiClient.callApi(
        '/CreateChannel', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create a channel colour mapping
     * Create a channel colour mapping
     * @param {module:com.alterian.ja.model/CreateChannelRequest} createChannelRequest Create a channel colour mapping
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse}
     */
    createChannel(createChannelRequest) {
      return this.createChannelWithHttpInfo(createChannelRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Creates an event stream, including a datasource and a DDE queue
     * Creates an event stream, including a datasource and a DDE queue
     * @param {module:com.alterian.ja.model/CreateEventStreamRequest} createEventStreamRequest Creates an event stream, including a datasource and a DDE queue
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse} and HTTP response
     */
    createEventStreamWithHttpInfo(createEventStreamRequest) {
      let postBody = createEventStreamRequest;
      // verify the required parameter 'createEventStreamRequest' is set
      if (createEventStreamRequest === undefined || createEventStreamRequest === null) {
        throw new Error("Missing the required parameter 'createEventStreamRequest' when calling createEventStream");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateClientDefaultResponse;
      return this.apiClient.callApi(
        '/CreateEventStream', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Creates an event stream, including a datasource and a DDE queue
     * Creates an event stream, including a datasource and a DDE queue
     * @param {module:com.alterian.ja.model/CreateEventStreamRequest} createEventStreamRequest Creates an event stream, including a datasource and a DDE queue
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse}
     */
    createEventStream(createEventStreamRequest) {
      return this.createEventStreamWithHttpInfo(createEventStreamRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod)
     * Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod)
     * @param {module:com.alterian.ja.model/CreateEventStreamGroupRequest} createEventStreamGroupRequest Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse} and HTTP response
     */
    createEventStreamGroupWithHttpInfo(createEventStreamGroupRequest) {
      let postBody = createEventStreamGroupRequest;
      // verify the required parameter 'createEventStreamGroupRequest' is set
      if (createEventStreamGroupRequest === undefined || createEventStreamGroupRequest === null) {
        throw new Error("Missing the required parameter 'createEventStreamGroupRequest' when calling createEventStreamGroup");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateClientDefaultResponse;
      return this.apiClient.callApi(
        '/CreateEventStreamGroup', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod)
     * Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod)
     * @param {module:com.alterian.ja.model/CreateEventStreamGroupRequest} createEventStreamGroupRequest Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse}
     */
    createEventStreamGroup(createEventStreamGroupRequest) {
      return this.createEventStreamGroupWithHttpInfo(createEventStreamGroupRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create an Idealised Journey
     * Create an Idealised Journey
     * @param {module:com.alterian.ja.model/CreateIdealisedJourneyRequest} createIdealisedJourneyRequest Create an Idealised Journey
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse} and HTTP response
     */
    createIdealisedJourneyWithHttpInfo(createIdealisedJourneyRequest) {
      let postBody = createIdealisedJourneyRequest;
      // verify the required parameter 'createIdealisedJourneyRequest' is set
      if (createIdealisedJourneyRequest === undefined || createIdealisedJourneyRequest === null) {
        throw new Error("Missing the required parameter 'createIdealisedJourneyRequest' when calling createIdealisedJourney");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateClientDefaultResponse;
      return this.apiClient.callApi(
        '/CreateIdealisedJourney', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create an Idealised Journey
     * Create an Idealised Journey
     * @param {module:com.alterian.ja.model/CreateIdealisedJourneyRequest} createIdealisedJourneyRequest Create an Idealised Journey
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse}
     */
    createIdealisedJourney(createIdealisedJourneyRequest) {
      return this.createIdealisedJourneyWithHttpInfo(createIdealisedJourneyRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create a Sankey Favourite
     * Create a Sankey Favourite
     * @param {module:com.alterian.ja.model/CreateSankeyFavouriteRequest} createSankeyFavouriteRequest Create a Sankey Favourite
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse} and HTTP response
     */
    createSankeyFavouriteWithHttpInfo(createSankeyFavouriteRequest) {
      let postBody = createSankeyFavouriteRequest;
      // verify the required parameter 'createSankeyFavouriteRequest' is set
      if (createSankeyFavouriteRequest === undefined || createSankeyFavouriteRequest === null) {
        throw new Error("Missing the required parameter 'createSankeyFavouriteRequest' when calling createSankeyFavourite");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateClientDefaultResponse;
      return this.apiClient.callApi(
        '/CreateSankeyFavourite', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create a Sankey Favourite
     * Create a Sankey Favourite
     * @param {module:com.alterian.ja.model/CreateSankeyFavouriteRequest} createSankeyFavouriteRequest Create a Sankey Favourite
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse}
     */
    createSankeyFavourite(createSankeyFavouriteRequest) {
      return this.createSankeyFavouriteWithHttpInfo(createSankeyFavouriteRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Create a Visualisation Favourite
     * Create a Visualisation Favourite
     * @param {module:com.alterian.ja.model/CreateVisualisationFavouriteRequest} createVisualisationFavouriteRequest Create a Visualisation Favourite
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse} and HTTP response
     */
    createVisualisationFavouriteWithHttpInfo(createVisualisationFavouriteRequest) {
      let postBody = createVisualisationFavouriteRequest;
      // verify the required parameter 'createVisualisationFavouriteRequest' is set
      if (createVisualisationFavouriteRequest === undefined || createVisualisationFavouriteRequest === null) {
        throw new Error("Missing the required parameter 'createVisualisationFavouriteRequest' when calling createVisualisationFavourite");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateClientDefaultResponse;
      return this.apiClient.callApi(
        '/CreateVisualisationFavourite', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Create a Visualisation Favourite
     * Create a Visualisation Favourite
     * @param {module:com.alterian.ja.model/CreateVisualisationFavouriteRequest} createVisualisationFavouriteRequest Create a Visualisation Favourite
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse}
     */
    createVisualisationFavourite(createVisualisationFavouriteRequest) {
      return this.createVisualisationFavouriteWithHttpInfo(createVisualisationFavouriteRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Removed a channel and its associated colour from the channel list.
     * Removed a channel and its associated colour from the channel list.
     * @param {module:com.alterian.ja.model/DeleteChannelRequest} deleteChannelRequest Removed a channel and its associated colour from the channel list.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    deleteChannelWithHttpInfo(deleteChannelRequest) {
      let postBody = deleteChannelRequest;
      // verify the required parameter 'deleteChannelRequest' is set
      if (deleteChannelRequest === undefined || deleteChannelRequest === null) {
        throw new Error("Missing the required parameter 'deleteChannelRequest' when calling deleteChannel");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/DeleteChannel', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Removed a channel and its associated colour from the channel list.
     * Removed a channel and its associated colour from the channel list.
     * @param {module:com.alterian.ja.model/DeleteChannelRequest} deleteChannelRequest Removed a channel and its associated colour from the channel list.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    deleteChannel(deleteChannelRequest) {
      return this.deleteChannelWithHttpInfo(deleteChannelRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided
     * Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided
     * @param {module:com.alterian.ja.model/DeleteEventStreamRequest} deleteEventStreamRequest Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    deleteEventStreamWithHttpInfo(deleteEventStreamRequest) {
      let postBody = deleteEventStreamRequest;
      // verify the required parameter 'deleteEventStreamRequest' is set
      if (deleteEventStreamRequest === undefined || deleteEventStreamRequest === null) {
        throw new Error("Missing the required parameter 'deleteEventStreamRequest' when calling deleteEventStream");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/DeleteEventStream', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided
     * Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided
     * @param {module:com.alterian.ja.model/DeleteEventStreamRequest} deleteEventStreamRequest Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    deleteEventStream(deleteEventStreamRequest) {
      return this.deleteEventStreamWithHttpInfo(deleteEventStreamRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @param {module:com.alterian.ja.model/DeleteEventStreamCustomerColumnsRequest} deleteEventStreamCustomerColumnsRequest Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    deleteEventStreamCustomerColumnsWithHttpInfo(deleteEventStreamCustomerColumnsRequest) {
      let postBody = deleteEventStreamCustomerColumnsRequest;
      // verify the required parameter 'deleteEventStreamCustomerColumnsRequest' is set
      if (deleteEventStreamCustomerColumnsRequest === undefined || deleteEventStreamCustomerColumnsRequest === null) {
        throw new Error("Missing the required parameter 'deleteEventStreamCustomerColumnsRequest' when calling deleteEventStreamCustomerColumns");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/DeleteEventStreamCustomerColumns', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @param {module:com.alterian.ja.model/DeleteEventStreamCustomerColumnsRequest} deleteEventStreamCustomerColumnsRequest Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    deleteEventStreamCustomerColumns(deleteEventStreamCustomerColumnsRequest) {
      return this.deleteEventStreamCustomerColumnsWithHttpInfo(deleteEventStreamCustomerColumnsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @param {module:com.alterian.ja.model/DeleteEventStreamCustomerColumnsFromGroupRequest} deleteEventStreamCustomerColumnsFromGroupRequest Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    deleteEventStreamCustomerColumnsFromGroupWithHttpInfo(deleteEventStreamCustomerColumnsFromGroupRequest) {
      let postBody = deleteEventStreamCustomerColumnsFromGroupRequest;
      // verify the required parameter 'deleteEventStreamCustomerColumnsFromGroupRequest' is set
      if (deleteEventStreamCustomerColumnsFromGroupRequest === undefined || deleteEventStreamCustomerColumnsFromGroupRequest === null) {
        throw new Error("Missing the required parameter 'deleteEventStreamCustomerColumnsFromGroupRequest' when calling deleteEventStreamCustomerColumnsFromGroup");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/DeleteEventStreamCustomerColumnsFromGroup', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @param {module:com.alterian.ja.model/DeleteEventStreamCustomerColumnsFromGroupRequest} deleteEventStreamCustomerColumnsFromGroupRequest Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    deleteEventStreamCustomerColumnsFromGroup(deleteEventStreamCustomerColumnsFromGroupRequest) {
      return this.deleteEventStreamCustomerColumnsFromGroupWithHttpInfo(deleteEventStreamCustomerColumnsFromGroupRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE.
     * Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE.
     * @param {module:com.alterian.ja.model/DeleteEventStreamGroupRequest} deleteEventStreamGroupRequest Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    deleteEventStreamGroupWithHttpInfo(deleteEventStreamGroupRequest) {
      let postBody = deleteEventStreamGroupRequest;
      // verify the required parameter 'deleteEventStreamGroupRequest' is set
      if (deleteEventStreamGroupRequest === undefined || deleteEventStreamGroupRequest === null) {
        throw new Error("Missing the required parameter 'deleteEventStreamGroupRequest' when calling deleteEventStreamGroup");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/DeleteEventStreamGroup', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE.
     * Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE.
     * @param {module:com.alterian.ja.model/DeleteEventStreamGroupRequest} deleteEventStreamGroupRequest Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    deleteEventStreamGroup(deleteEventStreamGroupRequest) {
      return this.deleteEventStreamGroupWithHttpInfo(deleteEventStreamGroupRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete Idealised Journey's
     * Delete Idealised Journey's
     * @param {module:com.alterian.ja.model/DeleteIdealisedJourneyRequest} deleteIdealisedJourneyRequest Delete Idealised Journey's
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    deleteIdealisedJourneyWithHttpInfo(deleteIdealisedJourneyRequest) {
      let postBody = deleteIdealisedJourneyRequest;
      // verify the required parameter 'deleteIdealisedJourneyRequest' is set
      if (deleteIdealisedJourneyRequest === undefined || deleteIdealisedJourneyRequest === null) {
        throw new Error("Missing the required parameter 'deleteIdealisedJourneyRequest' when calling deleteIdealisedJourney");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/DeleteIdealisedJourney', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete Idealised Journey's
     * Delete Idealised Journey's
     * @param {module:com.alterian.ja.model/DeleteIdealisedJourneyRequest} deleteIdealisedJourneyRequest Delete Idealised Journey's
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    deleteIdealisedJourney(deleteIdealisedJourneyRequest) {
      return this.deleteIdealisedJourneyWithHttpInfo(deleteIdealisedJourneyRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete a sankey favourite
     * Delete a sankey favourite
     * @param {module:com.alterian.ja.model/DeleteSankeyFavouritesRequest} deleteSankeyFavouritesRequest Delete a sankey favourite
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    deleteSankeyFavouritesWithHttpInfo(deleteSankeyFavouritesRequest) {
      let postBody = deleteSankeyFavouritesRequest;
      // verify the required parameter 'deleteSankeyFavouritesRequest' is set
      if (deleteSankeyFavouritesRequest === undefined || deleteSankeyFavouritesRequest === null) {
        throw new Error("Missing the required parameter 'deleteSankeyFavouritesRequest' when calling deleteSankeyFavourites");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/DeleteSankeyFavourites', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete a sankey favourite
     * Delete a sankey favourite
     * @param {module:com.alterian.ja.model/DeleteSankeyFavouritesRequest} deleteSankeyFavouritesRequest Delete a sankey favourite
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    deleteSankeyFavourites(deleteSankeyFavouritesRequest) {
      return this.deleteSankeyFavouritesWithHttpInfo(deleteSankeyFavouritesRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete Visualisation favourite(s)
     * Delete Visualisation favourite(s)
     * @param {module:com.alterian.ja.model/DeleteVisualisationFavouritesRequest} deleteVisualisationFavouritesRequest Delete Visualisation favourite(s)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    deleteVisualisationFavouritesWithHttpInfo(deleteVisualisationFavouritesRequest) {
      let postBody = deleteVisualisationFavouritesRequest;
      // verify the required parameter 'deleteVisualisationFavouritesRequest' is set
      if (deleteVisualisationFavouritesRequest === undefined || deleteVisualisationFavouritesRequest === null) {
        throw new Error("Missing the required parameter 'deleteVisualisationFavouritesRequest' when calling deleteVisualisationFavourites");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/DeleteVisualisationFavourites', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete Visualisation favourite(s)
     * Delete Visualisation favourite(s)
     * @param {module:com.alterian.ja.model/DeleteVisualisationFavouritesRequest} deleteVisualisationFavouritesRequest Delete Visualisation favourite(s)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    deleteVisualisationFavourites(deleteVisualisationFavouritesRequest) {
      return this.deleteVisualisationFavouritesWithHttpInfo(deleteVisualisationFavouritesRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEvents' to False.
     * Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEvents' to False.
     * @param {module:com.alterian.ja.model/ExportEventStreamInteractionRequest} exportEventStreamInteractionRequest Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEvents' to False.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link File} and HTTP response
     */
    exportEventStreamInteractionWithHttpInfo(exportEventStreamInteractionRequest) {
      let postBody = exportEventStreamInteractionRequest;
      // verify the required parameter 'exportEventStreamInteractionRequest' is set
      if (exportEventStreamInteractionRequest === undefined || exportEventStreamInteractionRequest === null) {
        throw new Error("Missing the required parameter 'exportEventStreamInteractionRequest' when calling exportEventStreamInteraction");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = File;
      return this.apiClient.callApi(
        '/ExportEventStreamInteraction', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEvents' to False.
     * Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEvents' to False.
     * @param {module:com.alterian.ja.model/ExportEventStreamInteractionRequest} exportEventStreamInteractionRequest Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEvents' to False.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link File}
     */
    exportEventStreamInteraction(exportEventStreamInteractionRequest) {
      return this.exportEventStreamInteractionWithHttpInfo(exportEventStreamInteractionRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Return back a list of channels and their associated colours
     * Return back a list of channels and their associated colours
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetChannelsDefaultResponse} and HTTP response
     */
    getChannelsWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = GetChannelsDefaultResponse;
      return this.apiClient.callApi(
        '/GetChannels', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Return back a list of channels and their associated colours
     * Return back a list of channels and their associated colours
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetChannelsDefaultResponse}
     */
    getChannels() {
      return this.getChannelsWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Obtain the event records from an event stream table that match the specified key
     * Obtain the event records from an event stream table that match the specified key
     * @param {module:com.alterian.ja.model/GetEventRecordsRequest} getEventRecordsRequest Obtain the event records from an event stream table that match the specified key
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetEventRecordsDefaultResponse} and HTTP response
     */
    getEventRecordsWithHttpInfo(getEventRecordsRequest) {
      let postBody = getEventRecordsRequest;
      // verify the required parameter 'getEventRecordsRequest' is set
      if (getEventRecordsRequest === undefined || getEventRecordsRequest === null) {
        throw new Error("Missing the required parameter 'getEventRecordsRequest' when calling getEventRecords");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetEventRecordsDefaultResponse;
      return this.apiClient.callApi(
        '/GetEventRecords', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Obtain the event records from an event stream table that match the specified key
     * Obtain the event records from an event stream table that match the specified key
     * @param {module:com.alterian.ja.model/GetEventRecordsRequest} getEventRecordsRequest Obtain the event records from an event stream table that match the specified key
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetEventRecordsDefaultResponse}
     */
    getEventRecords(getEventRecordsRequest) {
      return this.getEventRecordsWithHttpInfo(getEventRecordsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams)
     * Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams)
     * @param {module:com.alterian.ja.model/GetEventStreamRequest} getEventStreamRequest Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetEventStreamDefaultResponse} and HTTP response
     */
    getEventStreamWithHttpInfo(getEventStreamRequest) {
      let postBody = getEventStreamRequest;
      // verify the required parameter 'getEventStreamRequest' is set
      if (getEventStreamRequest === undefined || getEventStreamRequest === null) {
        throw new Error("Missing the required parameter 'getEventStreamRequest' when calling getEventStream");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetEventStreamDefaultResponse;
      return this.apiClient.callApi(
        '/GetEventStream', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams)
     * Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams)
     * @param {module:com.alterian.ja.model/GetEventStreamRequest} getEventStreamRequest Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetEventStreamDefaultResponse}
     */
    getEventStream(getEventStreamRequest) {
      return this.getEventStreamWithHttpInfo(getEventStreamRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won't have the financial columns yet)
     * Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won't have the financial columns yet)
     * @param {module:com.alterian.ja.model/GetEventStreamAggregatesRequest} getEventStreamAggregatesRequest Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won't have the financial columns yet)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetEventRecordsDefaultResponse} and HTTP response
     */
    getEventStreamAggregatesWithHttpInfo(getEventStreamAggregatesRequest) {
      let postBody = getEventStreamAggregatesRequest;
      // verify the required parameter 'getEventStreamAggregatesRequest' is set
      if (getEventStreamAggregatesRequest === undefined || getEventStreamAggregatesRequest === null) {
        throw new Error("Missing the required parameter 'getEventStreamAggregatesRequest' when calling getEventStreamAggregates");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetEventRecordsDefaultResponse;
      return this.apiClient.callApi(
        '/GetEventStreamAggregates', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won't have the financial columns yet)
     * Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won't have the financial columns yet)
     * @param {module:com.alterian.ja.model/GetEventStreamAggregatesRequest} getEventStreamAggregatesRequest Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won't have the financial columns yet)
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetEventRecordsDefaultResponse}
     */
    getEventStreamAggregates(getEventStreamAggregatesRequest) {
      return this.getEventStreamAggregatesWithHttpInfo(getEventStreamAggregatesRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s
     * Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s
     * @param {module:com.alterian.ja.model/GetEventStreamChannelsRequest} getEventStreamChannelsRequest Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetDataSourceUsersDefaultResponse} and HTTP response
     */
    getEventStreamChannelsWithHttpInfo(getEventStreamChannelsRequest) {
      let postBody = getEventStreamChannelsRequest;
      // verify the required parameter 'getEventStreamChannelsRequest' is set
      if (getEventStreamChannelsRequest === undefined || getEventStreamChannelsRequest === null) {
        throw new Error("Missing the required parameter 'getEventStreamChannelsRequest' when calling getEventStreamChannels");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetDataSourceUsersDefaultResponse;
      return this.apiClient.callApi(
        '/GetEventStreamChannels', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s
     * Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s
     * @param {module:com.alterian.ja.model/GetEventStreamChannelsRequest} getEventStreamChannelsRequest Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetDataSourceUsersDefaultResponse}
     */
    getEventStreamChannels(getEventStreamChannelsRequest) {
      return this.getEventStreamChannelsWithHttpInfo(getEventStreamChannelsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly
     * @param {module:com.alterian.ja.model/GetEventStreamDecodeMappingsRequest} getEventStreamDecodeMappingsRequest Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetEventStreamDecodeMappingsDefaultResponse} and HTTP response
     */
    getEventStreamDecodeMappingsWithHttpInfo(getEventStreamDecodeMappingsRequest) {
      let postBody = getEventStreamDecodeMappingsRequest;
      // verify the required parameter 'getEventStreamDecodeMappingsRequest' is set
      if (getEventStreamDecodeMappingsRequest === undefined || getEventStreamDecodeMappingsRequest === null) {
        throw new Error("Missing the required parameter 'getEventStreamDecodeMappingsRequest' when calling getEventStreamDecodeMappings");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetEventStreamDecodeMappingsDefaultResponse;
      return this.apiClient.callApi(
        '/GetEventStreamDecodeMappings', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly
     * @param {module:com.alterian.ja.model/GetEventStreamDecodeMappingsRequest} getEventStreamDecodeMappingsRequest Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetEventStreamDecodeMappingsDefaultResponse}
     */
    getEventStreamDecodeMappings(getEventStreamDecodeMappingsRequest) {
      return this.getEventStreamDecodeMappingsWithHttpInfo(getEventStreamDecodeMappingsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist
     * @param {module:com.alterian.ja.model/GetEventStreamDecodeTargetDiscretesRequest} getEventStreamDecodeTargetDiscretesRequest Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetEventStreamDecodeTargetDiscretesDefaultResponse} and HTTP response
     */
    getEventStreamDecodeTargetDiscretesWithHttpInfo(getEventStreamDecodeTargetDiscretesRequest) {
      let postBody = getEventStreamDecodeTargetDiscretesRequest;
      // verify the required parameter 'getEventStreamDecodeTargetDiscretesRequest' is set
      if (getEventStreamDecodeTargetDiscretesRequest === undefined || getEventStreamDecodeTargetDiscretesRequest === null) {
        throw new Error("Missing the required parameter 'getEventStreamDecodeTargetDiscretesRequest' when calling getEventStreamDecodeTargetDiscretes");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetEventStreamDecodeTargetDiscretesDefaultResponse;
      return this.apiClient.callApi(
        '/GetEventStreamDecodeTargetDiscretes', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist
     * @param {module:com.alterian.ja.model/GetEventStreamDecodeTargetDiscretesRequest} getEventStreamDecodeTargetDiscretesRequest Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetEventStreamDecodeTargetDiscretesDefaultResponse}
     */
    getEventStreamDecodeTargetDiscretes(getEventStreamDecodeTargetDiscretesRequest) {
      return this.getEventStreamDecodeTargetDiscretesWithHttpInfo(getEventStreamDecodeTargetDiscretesRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \"No data is available for the specified filters\" as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned
     * Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \"No data is available for the specified filters\" as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned
     * @param {module:com.alterian.ja.model/GetEventStreamDiscreteValuesRequest} getEventStreamDiscreteValuesRequest Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \"No data is available for the specified filters\" as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetEventStreamDiscreteValuesDefaultResponse} and HTTP response
     */
    getEventStreamDiscreteValuesWithHttpInfo(getEventStreamDiscreteValuesRequest) {
      let postBody = getEventStreamDiscreteValuesRequest;
      // verify the required parameter 'getEventStreamDiscreteValuesRequest' is set
      if (getEventStreamDiscreteValuesRequest === undefined || getEventStreamDiscreteValuesRequest === null) {
        throw new Error("Missing the required parameter 'getEventStreamDiscreteValuesRequest' when calling getEventStreamDiscreteValues");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetEventStreamDiscreteValuesDefaultResponse;
      return this.apiClient.callApi(
        '/GetEventStreamDiscreteValues', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \"No data is available for the specified filters\" as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned
     * Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \"No data is available for the specified filters\" as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned
     * @param {module:com.alterian.ja.model/GetEventStreamDiscreteValuesRequest} getEventStreamDiscreteValuesRequest Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \"No data is available for the specified filters\" as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetEventStreamDiscreteValuesDefaultResponse}
     */
    getEventStreamDiscreteValues(getEventStreamDiscreteValuesRequest) {
      return this.getEventStreamDiscreteValuesWithHttpInfo(getEventStreamDiscreteValuesRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieve available models
     * Retrieve available models
     * @param {module:com.alterian.ja.model/GetEventStreamModelsRequest} getEventStreamModelsRequest Retrieve available models
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetEventStreamModelsDefaultResponse} and HTTP response
     */
    getEventStreamModelsWithHttpInfo(getEventStreamModelsRequest) {
      let postBody = getEventStreamModelsRequest;
      // verify the required parameter 'getEventStreamModelsRequest' is set
      if (getEventStreamModelsRequest === undefined || getEventStreamModelsRequest === null) {
        throw new Error("Missing the required parameter 'getEventStreamModelsRequest' when calling getEventStreamModels");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetEventStreamModelsDefaultResponse;
      return this.apiClient.callApi(
        '/GetEventStreamModels', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieve available models
     * Retrieve available models
     * @param {module:com.alterian.ja.model/GetEventStreamModelsRequest} getEventStreamModelsRequest Retrieve available models
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetEventStreamModelsDefaultResponse}
     */
    getEventStreamModels(getEventStreamModelsRequest) {
      return this.getEventStreamModelsWithHttpInfo(getEventStreamModelsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Returns back a list of event streams which exist in the system
     * Returns back a list of event streams which exist in the system
     * @param {module:com.alterian.ja.model/GetClientSetsRequest} getClientSetsRequest Returns back a list of event streams which exist in the system
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetEventStreamsDefaultResponse} and HTTP response
     */
    getEventStreamsWithHttpInfo(getClientSetsRequest) {
      let postBody = getClientSetsRequest;
      // verify the required parameter 'getClientSetsRequest' is set
      if (getClientSetsRequest === undefined || getClientSetsRequest === null) {
        throw new Error("Missing the required parameter 'getClientSetsRequest' when calling getEventStreams");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetEventStreamsDefaultResponse;
      return this.apiClient.callApi(
        '/GetEventStreams', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Returns back a list of event streams which exist in the system
     * Returns back a list of event streams which exist in the system
     * @param {module:com.alterian.ja.model/GetClientSetsRequest} getClientSetsRequest Returns back a list of event streams which exist in the system
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetEventStreamsDefaultResponse}
     */
    getEventStreams(getClientSetsRequest) {
      return this.getEventStreamsWithHttpInfo(getClientSetsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied
     * Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied
     * @param {module:com.alterian.ja.model/GetFieldTransformationDiscreteValuesRequest} getFieldTransformationDiscreteValuesRequest Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetEventStreamDecodeTargetDiscretesDefaultResponse} and HTTP response
     */
    getFieldTransformationDiscreteValuesWithHttpInfo(getFieldTransformationDiscreteValuesRequest) {
      let postBody = getFieldTransformationDiscreteValuesRequest;
      // verify the required parameter 'getFieldTransformationDiscreteValuesRequest' is set
      if (getFieldTransformationDiscreteValuesRequest === undefined || getFieldTransformationDiscreteValuesRequest === null) {
        throw new Error("Missing the required parameter 'getFieldTransformationDiscreteValuesRequest' when calling getFieldTransformationDiscreteValues");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetEventStreamDecodeTargetDiscretesDefaultResponse;
      return this.apiClient.callApi(
        '/GetFieldTransformationDiscreteValues', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied
     * Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied
     * @param {module:com.alterian.ja.model/GetFieldTransformationDiscreteValuesRequest} getFieldTransformationDiscreteValuesRequest Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetEventStreamDecodeTargetDiscretesDefaultResponse}
     */
    getFieldTransformationDiscreteValues(getFieldTransformationDiscreteValuesRequest) {
      return this.getFieldTransformationDiscreteValuesWithHttpInfo(getFieldTransformationDiscreteValuesRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column
     * Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column
     * @param {module:com.alterian.ja.model/GetFieldTransformationMappingsRequest} getFieldTransformationMappingsRequest Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetFieldTransformationMappingsDefaultResponse} and HTTP response
     */
    getFieldTransformationMappingsWithHttpInfo(getFieldTransformationMappingsRequest) {
      let postBody = getFieldTransformationMappingsRequest;
      // verify the required parameter 'getFieldTransformationMappingsRequest' is set
      if (getFieldTransformationMappingsRequest === undefined || getFieldTransformationMappingsRequest === null) {
        throw new Error("Missing the required parameter 'getFieldTransformationMappingsRequest' when calling getFieldTransformationMappings");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetFieldTransformationMappingsDefaultResponse;
      return this.apiClient.callApi(
        '/GetFieldTransformationMappings', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column
     * Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column
     * @param {module:com.alterian.ja.model/GetFieldTransformationMappingsRequest} getFieldTransformationMappingsRequest Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetFieldTransformationMappingsDefaultResponse}
     */
    getFieldTransformationMappings(getFieldTransformationMappingsRequest) {
      return this.getFieldTransformationMappingsWithHttpInfo(getFieldTransformationMappingsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieve a list of Idealised Journeys
     * Retrieve a list of Idealised Journeys
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetIdealisedJourneysDefaultResponse} and HTTP response
     */
    getIdealisedJourneysWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = GetIdealisedJourneysDefaultResponse;
      return this.apiClient.callApi(
        '/GetIdealisedJourneys', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieve a list of Idealised Journeys
     * Retrieve a list of Idealised Journeys
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetIdealisedJourneysDefaultResponse}
     */
    getIdealisedJourneys() {
      return this.getIdealisedJourneysWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieve a list of Sankey Favourites
     * Retrieve a list of Sankey Favourites
     * @param {module:com.alterian.ja.model/GetSankeyFavouritesRequest} getSankeyFavouritesRequest Retrieve a list of Sankey Favourites
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetSankeyFavouritesDefaultResponse} and HTTP response
     */
    getSankeyFavouritesWithHttpInfo(getSankeyFavouritesRequest) {
      let postBody = getSankeyFavouritesRequest;
      // verify the required parameter 'getSankeyFavouritesRequest' is set
      if (getSankeyFavouritesRequest === undefined || getSankeyFavouritesRequest === null) {
        throw new Error("Missing the required parameter 'getSankeyFavouritesRequest' when calling getSankeyFavourites");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetSankeyFavouritesDefaultResponse;
      return this.apiClient.callApi(
        '/GetSankeyFavourites', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieve a list of Sankey Favourites
     * Retrieve a list of Sankey Favourites
     * @param {module:com.alterian.ja.model/GetSankeyFavouritesRequest} getSankeyFavouritesRequest Retrieve a list of Sankey Favourites
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetSankeyFavouritesDefaultResponse}
     */
    getSankeyFavourites(getSankeyFavouritesRequest) {
      return this.getSankeyFavouritesWithHttpInfo(getSankeyFavouritesRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Retrieve a list of Visualisation Favourites
     * Retrieve a list of Visualisation Favourites
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetVisualisationFavouritesDefaultResponse} and HTTP response
     */
    getVisualisationFavouritesWithHttpInfo() {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = GetVisualisationFavouritesDefaultResponse;
      return this.apiClient.callApi(
        '/GetVisualisationFavourites', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Retrieve a list of Visualisation Favourites
     * Retrieve a list of Visualisation Favourites
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetVisualisationFavouritesDefaultResponse}
     */
    getVisualisationFavourites() {
      return this.getVisualisationFavouritesWithHttpInfo()
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The 'Drop off' points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an 'other events' category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a 'no event' category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5.
     * Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The 'Drop off' points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an 'other events' category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a 'no event' category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5.
     * @param {module:com.alterian.ja.model/QueryEventStreamRequest} queryEventStreamRequest Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The 'Drop off' points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an 'other events' category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a 'no event' category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/QueryEventStreamDefaultResponse} and HTTP response
     */
    queryEventStreamWithHttpInfo(queryEventStreamRequest) {
      let postBody = queryEventStreamRequest;
      // verify the required parameter 'queryEventStreamRequest' is set
      if (queryEventStreamRequest === undefined || queryEventStreamRequest === null) {
        throw new Error("Missing the required parameter 'queryEventStreamRequest' when calling queryEventStream");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = QueryEventStreamDefaultResponse;
      return this.apiClient.callApi(
        '/QueryEventStream', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The 'Drop off' points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an 'other events' category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a 'no event' category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5.
     * Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The 'Drop off' points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an 'other events' category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a 'no event' category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5.
     * @param {module:com.alterian.ja.model/QueryEventStreamRequest} queryEventStreamRequest Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The 'Drop off' points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an 'other events' category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a 'no event' category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/QueryEventStreamDefaultResponse}
     */
    queryEventStream(queryEventStreamRequest) {
      return this.queryEventStreamWithHttpInfo(queryEventStreamRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter
     * Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter
     * @param {module:com.alterian.ja.model/QueryEventStreamCountRequest} queryEventStreamCountRequest Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/QueryEventStreamCountDefaultResponse} and HTTP response
     */
    queryEventStreamCountWithHttpInfo(queryEventStreamCountRequest) {
      let postBody = queryEventStreamCountRequest;
      // verify the required parameter 'queryEventStreamCountRequest' is set
      if (queryEventStreamCountRequest === undefined || queryEventStreamCountRequest === null) {
        throw new Error("Missing the required parameter 'queryEventStreamCountRequest' when calling queryEventStreamCount");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = QueryEventStreamCountDefaultResponse;
      return this.apiClient.callApi(
        '/QueryEventStreamCount', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter
     * Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter
     * @param {module:com.alterian.ja.model/QueryEventStreamCountRequest} queryEventStreamCountRequest Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/QueryEventStreamCountDefaultResponse}
     */
    queryEventStreamCount(queryEventStreamCountRequest) {
      return this.queryEventStreamCountWithHttpInfo(queryEventStreamCountRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEvents' to False.
     * Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEvents' to False.
     * @param {module:com.alterian.ja.model/ExportEventStreamInteractionRequest} exportEventStreamInteractionRequest Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEvents' to False.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetEventRecordsDefaultResponse} and HTTP response
     */
    queryEventStreamInteractionWithHttpInfo(exportEventStreamInteractionRequest) {
      let postBody = exportEventStreamInteractionRequest;
      // verify the required parameter 'exportEventStreamInteractionRequest' is set
      if (exportEventStreamInteractionRequest === undefined || exportEventStreamInteractionRequest === null) {
        throw new Error("Missing the required parameter 'exportEventStreamInteractionRequest' when calling queryEventStreamInteraction");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetEventRecordsDefaultResponse;
      return this.apiClient.callApi(
        '/QueryEventStreamInteraction', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEvents' to False.
     * Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEvents' to False.
     * @param {module:com.alterian.ja.model/ExportEventStreamInteractionRequest} exportEventStreamInteractionRequest Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEvents' to False.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetEventRecordsDefaultResponse}
     */
    queryEventStreamInteraction(exportEventStreamInteractionRequest) {
      return this.queryEventStreamInteractionWithHttpInfo(exportEventStreamInteractionRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEventsFrom' / IncludeMatchedEventsTo to False.
     * Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEventsFrom' / IncludeMatchedEventsTo to False.
     * @param {module:com.alterian.ja.model/QueryEventStreamTransitionRequest} queryEventStreamTransitionRequest Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEventsFrom' / IncludeMatchedEventsTo to False.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetEventRecordsDefaultResponse} and HTTP response
     */
    queryEventStreamTransitionWithHttpInfo(queryEventStreamTransitionRequest) {
      let postBody = queryEventStreamTransitionRequest;
      // verify the required parameter 'queryEventStreamTransitionRequest' is set
      if (queryEventStreamTransitionRequest === undefined || queryEventStreamTransitionRequest === null) {
        throw new Error("Missing the required parameter 'queryEventStreamTransitionRequest' when calling queryEventStreamTransition");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetEventRecordsDefaultResponse;
      return this.apiClient.callApi(
        '/QueryEventStreamTransition', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEventsFrom' / IncludeMatchedEventsTo to False.
     * Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEventsFrom' / IncludeMatchedEventsTo to False.
     * @param {module:com.alterian.ja.model/QueryEventStreamTransitionRequest} queryEventStreamTransitionRequest Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \"other\" events pass all displayed events and set 'IncludeMatchedEventsFrom' / IncludeMatchedEventsTo to False.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetEventRecordsDefaultResponse}
     */
    queryEventStreamTransition(queryEventStreamTransitionRequest) {
      return this.queryEventStreamTransitionWithHttpInfo(queryEventStreamTransitionRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Train and employ sequence prediction models for an event stream
     * Train and employ sequence prediction models for an event stream
     * @param {module:com.alterian.ja.model/RunSequencePredictorRequest} runSequencePredictorRequest Train and employ sequence prediction models for an event stream
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/RunSequencePredictorDefaultResponse} and HTTP response
     */
    runSequencePredictorWithHttpInfo(runSequencePredictorRequest) {
      let postBody = runSequencePredictorRequest;
      // verify the required parameter 'runSequencePredictorRequest' is set
      if (runSequencePredictorRequest === undefined || runSequencePredictorRequest === null) {
        throw new Error("Missing the required parameter 'runSequencePredictorRequest' when calling runSequencePredictor");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = RunSequencePredictorDefaultResponse;
      return this.apiClient.callApi(
        '/RunSequencePredictor', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Train and employ sequence prediction models for an event stream
     * Train and employ sequence prediction models for an event stream
     * @param {module:com.alterian.ja.model/RunSequencePredictorRequest} runSequencePredictorRequest Train and employ sequence prediction models for an event stream
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/RunSequencePredictorDefaultResponse}
     */
    runSequencePredictor(runSequencePredictorRequest) {
      return this.runSequencePredictorWithHttpInfo(runSequencePredictorRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Updates a channel, allowing you to change the name and colour
     * Updates a channel, allowing you to change the name and colour
     * @param {module:com.alterian.ja.model/UpdateChannelRequest} updateChannelRequest Updates a channel, allowing you to change the name and colour
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    updateChannelWithHttpInfo(updateChannelRequest) {
      let postBody = updateChannelRequest;
      // verify the required parameter 'updateChannelRequest' is set
      if (updateChannelRequest === undefined || updateChannelRequest === null) {
        throw new Error("Missing the required parameter 'updateChannelRequest' when calling updateChannel");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/UpdateChannel', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Updates a channel, allowing you to change the name and colour
     * Updates a channel, allowing you to change the name and colour
     * @param {module:com.alterian.ja.model/UpdateChannelRequest} updateChannelRequest Updates a channel, allowing you to change the name and colour
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    updateChannel(updateChannelRequest) {
      return this.updateChannelWithHttpInfo(updateChannelRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced
     * Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced
     * @param {module:com.alterian.ja.model/UpdateEventStreamFieldTransformListsRequest} updateEventStreamFieldTransformListsRequest Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    updateEventStreamFieldTransformListsWithHttpInfo(updateEventStreamFieldTransformListsRequest) {
      let postBody = updateEventStreamFieldTransformListsRequest;
      // verify the required parameter 'updateEventStreamFieldTransformListsRequest' is set
      if (updateEventStreamFieldTransformListsRequest === undefined || updateEventStreamFieldTransformListsRequest === null) {
        throw new Error("Missing the required parameter 'updateEventStreamFieldTransformListsRequest' when calling updateEventStreamFieldTransformLists");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/UpdateEventStreamFieldTransformLists', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced
     * Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced
     * @param {module:com.alterian.ja.model/UpdateEventStreamFieldTransformListsRequest} updateEventStreamFieldTransformListsRequest Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    updateEventStreamFieldTransformLists(updateEventStreamFieldTransformListsRequest) {
      return this.updateEventStreamFieldTransformListsWithHttpInfo(updateEventStreamFieldTransformListsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update an Idealised Journey
     * Update an Idealised Journey
     * @param {module:com.alterian.ja.model/UpdateIdealisedJourneyRequest} updateIdealisedJourneyRequest Update an Idealised Journey
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    updateIdealisedJourneyWithHttpInfo(updateIdealisedJourneyRequest) {
      let postBody = updateIdealisedJourneyRequest;
      // verify the required parameter 'updateIdealisedJourneyRequest' is set
      if (updateIdealisedJourneyRequest === undefined || updateIdealisedJourneyRequest === null) {
        throw new Error("Missing the required parameter 'updateIdealisedJourneyRequest' when calling updateIdealisedJourney");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/UpdateIdealisedJourney', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update an Idealised Journey
     * Update an Idealised Journey
     * @param {module:com.alterian.ja.model/UpdateIdealisedJourneyRequest} updateIdealisedJourneyRequest Update an Idealised Journey
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    updateIdealisedJourney(updateIdealisedJourneyRequest) {
      return this.updateIdealisedJourneyWithHttpInfo(updateIdealisedJourneyRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update a SankeyFavourite
     * Update a SankeyFavourite
     * @param {module:com.alterian.ja.model/UpdateSankeyFavouriteRequest} updateSankeyFavouriteRequest Update a SankeyFavourite
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    updateSankeyFavouriteWithHttpInfo(updateSankeyFavouriteRequest) {
      let postBody = updateSankeyFavouriteRequest;
      // verify the required parameter 'updateSankeyFavouriteRequest' is set
      if (updateSankeyFavouriteRequest === undefined || updateSankeyFavouriteRequest === null) {
        throw new Error("Missing the required parameter 'updateSankeyFavouriteRequest' when calling updateSankeyFavourite");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/UpdateSankeyFavourite', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update a SankeyFavourite
     * Update a SankeyFavourite
     * @param {module:com.alterian.ja.model/UpdateSankeyFavouriteRequest} updateSankeyFavouriteRequest Update a SankeyFavourite
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    updateSankeyFavourite(updateSankeyFavouriteRequest) {
      return this.updateSankeyFavouriteWithHttpInfo(updateSankeyFavouriteRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update a Visualisation Favourite
     * Update a Visualisation Favourite
     * @param {module:com.alterian.ja.model/UpdateVisualisationFavouriteRequest} updateVisualisationFavouriteRequest Update a Visualisation Favourite
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    updateVisualisationFavouriteWithHttpInfo(updateVisualisationFavouriteRequest) {
      let postBody = updateVisualisationFavouriteRequest;
      // verify the required parameter 'updateVisualisationFavouriteRequest' is set
      if (updateVisualisationFavouriteRequest === undefined || updateVisualisationFavouriteRequest === null) {
        throw new Error("Missing the required parameter 'updateVisualisationFavouriteRequest' when calling updateVisualisationFavourite");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/UpdateVisualisationFavourite', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update a Visualisation Favourite
     * Update a Visualisation Favourite
     * @param {module:com.alterian.ja.model/UpdateVisualisationFavouriteRequest} updateVisualisationFavouriteRequest Update a Visualisation Favourite
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    updateVisualisationFavourite(updateVisualisationFavouriteRequest) {
      return this.updateVisualisationFavouriteWithHttpInfo(updateVisualisationFavouriteRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.
     * Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.
     * @param {module:com.alterian.ja.model/UpsertEventStreamCustomerColumnsRequest} upsertEventStreamCustomerColumnsRequest Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    upsertEventStreamCustomerColumnsWithHttpInfo(upsertEventStreamCustomerColumnsRequest) {
      let postBody = upsertEventStreamCustomerColumnsRequest;
      // verify the required parameter 'upsertEventStreamCustomerColumnsRequest' is set
      if (upsertEventStreamCustomerColumnsRequest === undefined || upsertEventStreamCustomerColumnsRequest === null) {
        throw new Error("Missing the required parameter 'upsertEventStreamCustomerColumnsRequest' when calling upsertEventStreamCustomerColumns");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/UpsertEventStreamCustomerColumns', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.
     * Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.
     * @param {module:com.alterian.ja.model/UpsertEventStreamCustomerColumnsRequest} upsertEventStreamCustomerColumnsRequest Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    upsertEventStreamCustomerColumns(upsertEventStreamCustomerColumnsRequest) {
      return this.upsertEventStreamCustomerColumnsWithHttpInfo(upsertEventStreamCustomerColumnsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted
     * Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted
     * @param {module:com.alterian.ja.model/UpsertEventStreamCustomerColumnsToGroupRequest} upsertEventStreamCustomerColumnsToGroupRequest Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    upsertEventStreamCustomerColumnsToGroupWithHttpInfo(upsertEventStreamCustomerColumnsToGroupRequest) {
      let postBody = upsertEventStreamCustomerColumnsToGroupRequest;
      // verify the required parameter 'upsertEventStreamCustomerColumnsToGroupRequest' is set
      if (upsertEventStreamCustomerColumnsToGroupRequest === undefined || upsertEventStreamCustomerColumnsToGroupRequest === null) {
        throw new Error("Missing the required parameter 'upsertEventStreamCustomerColumnsToGroupRequest' when calling upsertEventStreamCustomerColumnsToGroup");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/UpsertEventStreamCustomerColumnsToGroup', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted
     * Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted
     * @param {module:com.alterian.ja.model/UpsertEventStreamCustomerColumnsToGroupRequest} upsertEventStreamCustomerColumnsToGroupRequest Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    upsertEventStreamCustomerColumnsToGroup(upsertEventStreamCustomerColumnsToGroupRequest) {
      return this.upsertEventStreamCustomerColumnsToGroupWithHttpInfo(upsertEventStreamCustomerColumnsToGroupRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


}
