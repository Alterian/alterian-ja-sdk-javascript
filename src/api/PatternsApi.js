/**
 * Journey Analytics API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 6.35.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import AUTHChangePasswordDefaultResponse from '../com.alterian.ja.model/AUTHChangePasswordDefaultResponse';
import CreateClientDefaultResponse from '../com.alterian.ja.model/CreateClientDefaultResponse';
import CreatePatternRequest from '../com.alterian.ja.model/CreatePatternRequest';
import CreatePatternTasksDefaultResponse from '../com.alterian.ja.model/CreatePatternTasksDefaultResponse';
import CreatePatternTasksRequest from '../com.alterian.ja.model/CreatePatternTasksRequest';
import DeletePatternRequest from '../com.alterian.ja.model/DeletePatternRequest';
import GetEventRecordsDefaultResponse from '../com.alterian.ja.model/GetEventRecordsDefaultResponse';
import GetPatternDefaultResponse from '../com.alterian.ja.model/GetPatternDefaultResponse';
import GetPatternRecordsRequest from '../com.alterian.ja.model/GetPatternRecordsRequest';
import GetPatternRequest from '../com.alterian.ja.model/GetPatternRequest';
import GetPatternTasksRequest from '../com.alterian.ja.model/GetPatternTasksRequest';
import GetPatternsDefaultResponse from '../com.alterian.ja.model/GetPatternsDefaultResponse';
import GetPatternsRequest from '../com.alterian.ja.model/GetPatternsRequest';
import GetRepeatingPatternItemScoresDefaultResponse from '../com.alterian.ja.model/GetRepeatingPatternItemScoresDefaultResponse';
import GetRepeatingPatternItemScoresRequest from '../com.alterian.ja.model/GetRepeatingPatternItemScoresRequest';
import GetRepeatingPatternItemsRequest from '../com.alterian.ja.model/GetRepeatingPatternItemsRequest';
import RequestCancelPatternTasksRequest from '../com.alterian.ja.model/RequestCancelPatternTasksRequest';
import UpdatePatternRequest from '../com.alterian.ja.model/UpdatePatternRequest';
import UpdateRepeatingPatternItemScoresRequest from '../com.alterian.ja.model/UpdateRepeatingPatternItemScoresRequest';

/**
* Patterns service.
* @module api/PatternsApi
* @version 6.35.0
*/
export default class PatternsApi {

    /**
    * Constructs a new PatternsApi. 
    * @alias module:api/PatternsApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }



    /**
     * Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it
     * Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it
     * @param {module:com.alterian.ja.model/CreatePatternRequest} createPatternRequest Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse} and HTTP response
     */
    createPatternWithHttpInfo(createPatternRequest) {
      let postBody = createPatternRequest;
      // verify the required parameter 'createPatternRequest' is set
      if (createPatternRequest === undefined || createPatternRequest === null) {
        throw new Error("Missing the required parameter 'createPatternRequest' when calling createPattern");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreateClientDefaultResponse;
      return this.apiClient.callApi(
        '/CreatePattern', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it
     * Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it
     * @param {module:com.alterian.ja.model/CreatePatternRequest} createPatternRequest Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/CreateClientDefaultResponse}
     */
    createPattern(createPatternRequest) {
      return this.createPatternWithHttpInfo(createPatternRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Creates a task to perform an action against a pattern definition
     * Creates a task to perform an action against a pattern definition
     * @param {module:com.alterian.ja.model/CreatePatternTasksRequest} createPatternTasksRequest Creates a task to perform an action against a pattern definition
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/CreatePatternTasksDefaultResponse} and HTTP response
     */
    createPatternTasksWithHttpInfo(createPatternTasksRequest) {
      let postBody = createPatternTasksRequest;
      // verify the required parameter 'createPatternTasksRequest' is set
      if (createPatternTasksRequest === undefined || createPatternTasksRequest === null) {
        throw new Error("Missing the required parameter 'createPatternTasksRequest' when calling createPatternTasks");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreatePatternTasksDefaultResponse;
      return this.apiClient.callApi(
        '/CreatePatternTasks', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Creates a task to perform an action against a pattern definition
     * Creates a task to perform an action against a pattern definition
     * @param {module:com.alterian.ja.model/CreatePatternTasksRequest} createPatternTasksRequest Creates a task to perform an action against a pattern definition
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/CreatePatternTasksDefaultResponse}
     */
    createPatternTasks(createPatternTasksRequest) {
      return this.createPatternTasksWithHttpInfo(createPatternTasksRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete one or more pattern definitions
     * Delete one or more pattern definitions
     * @param {module:com.alterian.ja.model/DeletePatternRequest} deletePatternRequest Delete one or more pattern definitions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    deletePatternWithHttpInfo(deletePatternRequest) {
      let postBody = deletePatternRequest;
      // verify the required parameter 'deletePatternRequest' is set
      if (deletePatternRequest === undefined || deletePatternRequest === null) {
        throw new Error("Missing the required parameter 'deletePatternRequest' when calling deletePattern");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/DeletePattern', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Delete one or more pattern definitions
     * Delete one or more pattern definitions
     * @param {module:com.alterian.ja.model/DeletePatternRequest} deletePatternRequest Delete one or more pattern definitions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    deletePattern(deletePatternRequest) {
      return this.deletePatternWithHttpInfo(deletePatternRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get a pattern definition
     * Get a pattern definition
     * @param {module:com.alterian.ja.model/GetPatternRequest} getPatternRequest Get a pattern definition
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetPatternDefaultResponse} and HTTP response
     */
    getPatternWithHttpInfo(getPatternRequest) {
      let postBody = getPatternRequest;
      // verify the required parameter 'getPatternRequest' is set
      if (getPatternRequest === undefined || getPatternRequest === null) {
        throw new Error("Missing the required parameter 'getPatternRequest' when calling getPattern");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetPatternDefaultResponse;
      return this.apiClient.callApi(
        '/GetPattern', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get a pattern definition
     * Get a pattern definition
     * @param {module:com.alterian.ja.model/GetPatternRequest} getPatternRequest Get a pattern definition
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetPatternDefaultResponse}
     */
    getPattern(getPatternRequest) {
      return this.getPatternWithHttpInfo(getPatternRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get records from a pattern table
     * Get records from a pattern table
     * @param {module:com.alterian.ja.model/GetPatternRecordsRequest} getPatternRecordsRequest Get records from a pattern table
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetEventRecordsDefaultResponse} and HTTP response
     */
    getPatternRecordsWithHttpInfo(getPatternRecordsRequest) {
      let postBody = getPatternRecordsRequest;
      // verify the required parameter 'getPatternRecordsRequest' is set
      if (getPatternRecordsRequest === undefined || getPatternRecordsRequest === null) {
        throw new Error("Missing the required parameter 'getPatternRecordsRequest' when calling getPatternRecords");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetEventRecordsDefaultResponse;
      return this.apiClient.callApi(
        '/GetPatternRecords', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get records from a pattern table
     * Get records from a pattern table
     * @param {module:com.alterian.ja.model/GetPatternRecordsRequest} getPatternRecordsRequest Get records from a pattern table
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetEventRecordsDefaultResponse}
     */
    getPatternRecords(getPatternRecordsRequest) {
      return this.getPatternRecordsWithHttpInfo(getPatternRecordsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Check on the status of pattern tasks
     * Check on the status of pattern tasks
     * @param {module:com.alterian.ja.model/GetPatternTasksRequest} getPatternTasksRequest Check on the status of pattern tasks
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/CreatePatternTasksDefaultResponse} and HTTP response
     */
    getPatternTasksWithHttpInfo(getPatternTasksRequest) {
      let postBody = getPatternTasksRequest;
      // verify the required parameter 'getPatternTasksRequest' is set
      if (getPatternTasksRequest === undefined || getPatternTasksRequest === null) {
        throw new Error("Missing the required parameter 'getPatternTasksRequest' when calling getPatternTasks");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = CreatePatternTasksDefaultResponse;
      return this.apiClient.callApi(
        '/GetPatternTasks', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Check on the status of pattern tasks
     * Check on the status of pattern tasks
     * @param {module:com.alterian.ja.model/GetPatternTasksRequest} getPatternTasksRequest Check on the status of pattern tasks
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/CreatePatternTasksDefaultResponse}
     */
    getPatternTasks(getPatternTasksRequest) {
      return this.getPatternTasksWithHttpInfo(getPatternTasksRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get one or more pattern definitions
     * Get one or more pattern definitions
     * @param {module:com.alterian.ja.model/GetPatternsRequest} getPatternsRequest Get one or more pattern definitions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetPatternsDefaultResponse} and HTTP response
     */
    getPatternsWithHttpInfo(getPatternsRequest) {
      let postBody = getPatternsRequest;
      // verify the required parameter 'getPatternsRequest' is set
      if (getPatternsRequest === undefined || getPatternsRequest === null) {
        throw new Error("Missing the required parameter 'getPatternsRequest' when calling getPatterns");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetPatternsDefaultResponse;
      return this.apiClient.callApi(
        '/GetPatterns', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get one or more pattern definitions
     * Get one or more pattern definitions
     * @param {module:com.alterian.ja.model/GetPatternsRequest} getPatternsRequest Get one or more pattern definitions
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetPatternsDefaultResponse}
     */
    getPatterns(getPatternsRequest) {
      return this.getPatternsWithHttpInfo(getPatternsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode 'alias' transform that has been published to the pattern             and sits along-side the sequence item data
     * Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode 'alias' transform that has been published to the pattern             and sits along-side the sequence item data
     * @param {module:com.alterian.ja.model/GetRepeatingPatternItemScoresRequest} getRepeatingPatternItemScoresRequest Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode 'alias' transform that has been published to the pattern             and sits along-side the sequence item data
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetRepeatingPatternItemScoresDefaultResponse} and HTTP response
     */
    getRepeatingPatternItemScoresWithHttpInfo(getRepeatingPatternItemScoresRequest) {
      let postBody = getRepeatingPatternItemScoresRequest;
      // verify the required parameter 'getRepeatingPatternItemScoresRequest' is set
      if (getRepeatingPatternItemScoresRequest === undefined || getRepeatingPatternItemScoresRequest === null) {
        throw new Error("Missing the required parameter 'getRepeatingPatternItemScoresRequest' when calling getRepeatingPatternItemScores");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetRepeatingPatternItemScoresDefaultResponse;
      return this.apiClient.callApi(
        '/GetRepeatingPatternItemScores', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode 'alias' transform that has been published to the pattern             and sits along-side the sequence item data
     * Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode 'alias' transform that has been published to the pattern             and sits along-side the sequence item data
     * @param {module:com.alterian.ja.model/GetRepeatingPatternItemScoresRequest} getRepeatingPatternItemScoresRequest Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode 'alias' transform that has been published to the pattern             and sits along-side the sequence item data
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetRepeatingPatternItemScoresDefaultResponse}
     */
    getRepeatingPatternItemScores(getRepeatingPatternItemScoresRequest) {
      return this.getRepeatingPatternItemScoresWithHttpInfo(getRepeatingPatternItemScoresRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern
     * Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern
     * @param {module:com.alterian.ja.model/GetRepeatingPatternItemsRequest} getRepeatingPatternItemsRequest Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/GetEventRecordsDefaultResponse} and HTTP response
     */
    getRepeatingPatternItemsWithHttpInfo(getRepeatingPatternItemsRequest) {
      let postBody = getRepeatingPatternItemsRequest;
      // verify the required parameter 'getRepeatingPatternItemsRequest' is set
      if (getRepeatingPatternItemsRequest === undefined || getRepeatingPatternItemsRequest === null) {
        throw new Error("Missing the required parameter 'getRepeatingPatternItemsRequest' when calling getRepeatingPatternItems");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = GetEventRecordsDefaultResponse;
      return this.apiClient.callApi(
        '/GetRepeatingPatternItems', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern
     * Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern
     * @param {module:com.alterian.ja.model/GetRepeatingPatternItemsRequest} getRepeatingPatternItemsRequest Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/GetEventRecordsDefaultResponse}
     */
    getRepeatingPatternItems(getRepeatingPatternItemsRequest) {
      return this.getRepeatingPatternItemsWithHttpInfo(getRepeatingPatternItemsRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running
     * Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running
     * @param {module:com.alterian.ja.model/RequestCancelPatternTasksRequest} requestCancelPatternTasksRequest Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    requestCancelPatternTasksWithHttpInfo(requestCancelPatternTasksRequest) {
      let postBody = requestCancelPatternTasksRequest;
      // verify the required parameter 'requestCancelPatternTasksRequest' is set
      if (requestCancelPatternTasksRequest === undefined || requestCancelPatternTasksRequest === null) {
        throw new Error("Missing the required parameter 'requestCancelPatternTasksRequest' when calling requestCancelPatternTasks");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/RequestCancelPatternTasks', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running
     * Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running
     * @param {module:com.alterian.ja.model/RequestCancelPatternTasksRequest} requestCancelPatternTasksRequest Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    requestCancelPatternTasks(requestCancelPatternTasksRequest) {
      return this.requestCancelPatternTasksWithHttpInfo(requestCancelPatternTasksRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Updates a Pattern definition.
     * Updates a Pattern definition.
     * @param {module:com.alterian.ja.model/UpdatePatternRequest} updatePatternRequest Updates a Pattern definition.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    updatePatternWithHttpInfo(updatePatternRequest) {
      let postBody = updatePatternRequest;
      // verify the required parameter 'updatePatternRequest' is set
      if (updatePatternRequest === undefined || updatePatternRequest === null) {
        throw new Error("Missing the required parameter 'updatePatternRequest' when calling updatePattern");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/UpdatePattern', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Updates a Pattern definition.
     * Updates a Pattern definition.
     * @param {module:com.alterian.ja.model/UpdatePatternRequest} updatePatternRequest Updates a Pattern definition.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    updatePattern(updatePatternRequest) {
      return this.updatePatternWithHttpInfo(updatePatternRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified 'alias' transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of 'unscoring' it at present
     * Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified 'alias' transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of 'unscoring' it at present
     * @param {module:com.alterian.ja.model/UpdateRepeatingPatternItemScoresRequest} updateRepeatingPatternItemScoresRequest Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified 'alias' transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of 'unscoring' it at present
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse} and HTTP response
     */
    updateRepeatingPatternItemScoresWithHttpInfo(updateRepeatingPatternItemScoresRequest) {
      let postBody = updateRepeatingPatternItemScoresRequest;
      // verify the required parameter 'updateRepeatingPatternItemScoresRequest' is set
      if (updateRepeatingPatternItemScoresRequest === undefined || updateRepeatingPatternItemScoresRequest === null) {
        throw new Error("Missing the required parameter 'updateRepeatingPatternItemScoresRequest' when calling updateRepeatingPatternItemScores");
      }

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['TokenAuth'];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = AUTHChangePasswordDefaultResponse;
      return this.apiClient.callApi(
        '/UpdateRepeatingPatternItemScores', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified 'alias' transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of 'unscoring' it at present
     * Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified 'alias' transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of 'unscoring' it at present
     * @param {module:com.alterian.ja.model/UpdateRepeatingPatternItemScoresRequest} updateRepeatingPatternItemScoresRequest Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified 'alias' transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of 'unscoring' it at present
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:com.alterian.ja.model/AUTHChangePasswordDefaultResponse}
     */
    updateRepeatingPatternItemScores(updateRepeatingPatternItemScoresRequest) {
      return this.updateRepeatingPatternItemScoresWithHttpInfo(updateRepeatingPatternItemScoresRequest)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


}
